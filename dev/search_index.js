var documenterSearchIndex = {"docs":
[{"location":"ideal/#Ideal-objects","page":"Ideal objects","title":"Ideal objects","text":"","category":"section"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"CurrentModule = Solids","category":"page"},{"location":"ideal/#Primitive-solids","page":"Ideal objects","title":"Primitive solids","text":"","category":"section"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"Solids.Square\nSolids.Circle\nSolids.Cube\nSolids.Cylinder\nSolids.Sphere\nSolids.Polygon\nSolids.Surface\nSolids.NeutralSolid","category":"page"},{"location":"ideal/#Solids.Square","page":"Ideal objects","title":"Solids.Square","text":"Square(size; origin, center=false)\n\nAn axis-parallel square or rectangle  with given size (scalar or vector of length 2).\n\n\n\n\n\n","category":"type"},{"location":"ideal/#Solids.Circle","page":"Ideal objects","title":"Solids.Circle","text":"Circle(radius)\n\nA circle. Discretization is done via the accuracy and precision parameters.\n\n\n\n\n\n","category":"type"},{"location":"ideal/#Solids.Cube","page":"Ideal objects","title":"Solids.Cube","text":"Cube(size; origin, center=false)\n\nA cube or parallelepiped  with given size (scalar or vector of length 3).\n\n\n\n\n\n","category":"type"},{"location":"ideal/#Meshes.Cylinder","page":"Ideal objects","title":"Meshes.Cylinder","text":"Cylinder(start, finish, radius)\n\nA right circular cylinder with start and finish points, and radius of revolution. See https://en.wikipedia.org/wiki/Cylinder. \n\n\n\n\n\n","category":"type"},{"location":"ideal/#Solids.Sphere","page":"Ideal objects","title":"Solids.Sphere","text":"Sphere(radius)\n\nA sphere. Discretization is done via the accuracy and precision parameters.\n\n\n\n\n\n","category":"type"},{"location":"ideal/#Solids.Polygon","page":"Ideal objects","title":"Solids.Polygon","text":"Polygon{T}\nPolygon([point1, point2, ...])\nPolygon(point1, point2, ...)\n\nA simple, closed polygon enclosed by the given vertices.\n\n\n\n\n\n","category":"type"},{"location":"ideal/#Solids.NeutralSolid","page":"Ideal objects","title":"Solids.NeutralSolid","text":"NeutralSolid{D,T}\n\nA convenience type representing either an empty or full solid. This exists mostly to provide a neutral element for union() and intersect() operators, hence the name. In those cases, it is impossible to know in advance the dimension of the returned solid; hence, as an exception to the general rule, the D type parameter is either the symbol :empty or :full.\n\nSince neutral objects are removed at compile-time from corresponding CSG operations, this should have no influence on the dimension of a top-level object.\n\nThe T type parameter is always Bool.\n\n\n\n\n\n","category":"type"},{"location":"ideal/#Transformations","page":"Ideal objects","title":"Transformations","text":"","category":"section"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"All transformations accept two possible syntaxes:","category":"page"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"    transform(parameters, solid1, solid2, ...)\n    transform(parameters) * solid1","category":"page"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"The second, multiplicative form allows easy chaining of transformations:","category":"page"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"    transform1(param1) * transform2(param2) * solid","category":"page"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"This form may also be applied to several solids by either wrapping them in a union, or equivalently, by applying it to a Vector of Solids:","category":"page"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"    transform(parameters) * [ solid1, solid2, ... ]","category":"page"},{"location":"ideal/#Affine-transformations","page":"Ideal objects","title":"Affine transformations","text":"","category":"section"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"Solids.mult_matrix\nSolids.translate\nSolids.scale\nSolids.rotate\nSolids.mirror","category":"page"},{"location":"ideal/#Solids.mult_matrix","page":"Ideal objects","title":"Solids.mult_matrix","text":"mult_matrix(a, [center=c], solid...)\nmult_matrix(a, b, solid...)\nmult_matrix(a, b) * solid\n\nRepresents the affine operation x -> a*x + b.\n\nExtended help\n\nnote: Types of `mult_matrix` parameters\nThe precise type of parameters a and b is not specified. Usually, a will be a matrix and b a vector, but this is left open on purpose; for instance, a can be a scalar (for a scaling) and b can be Val(false) for a linear operation. Any types so that a * Vector + b is defined will be accepted.Conversion to a matrix will be done when converting to OpenSCAD format.\n\nnote: Matrix multiplication\nChained mult_matrix operations will be combined into a single operation when possible. This saves time: multiple (3 × n) matrix multiplications are replaced by (3 × 3) multiplications, followed by a single (3 × n).\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Solids.translate","page":"Ideal objects","title":"Solids.translate","text":"translate(v, s...)\ntranslate(v) * s\n\nTranslates solids s... by vector v.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Solids.scale","page":"Ideal objects","title":"Solids.scale","text":"scale(a, s...; center=0)\nscale(a; center=0) * s\n\nScales solids s by factor a. If center is given then this will be the invariant point.\n\na may also be a vector, in which case coordinates will be multiplied by the associated diagonal matrix.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Solids.rotate","page":"Ideal objects","title":"Solids.rotate","text":"rotate(θ, {center=center}, {solid...})\nrotate(θ, axis=axis, {center=center}, {solid...})\n\nRotation around the Z-axis (in trigonometric direction, i.e. counter-clockwise).\n\n\n\n\n\nrotate((θ,φ,ψ), {center=center}, {solid...})\n\nRotation given by Euler angles (ZYX; same ordering as OpenSCAD).\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Solids.mirror","page":"Ideal objects","title":"Solids.mirror","text":"mirror(v, s...; center=0)\nmirror(v; center=0) * s\n\nReflection with axis given by the hyperplane normal to v. If center is given, then the affine hyperplane through this point will be used.\n\n\n\n\n\n","category":"function"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"TODO: Solids.project, Solids.cut.","category":"page"},{"location":"ideal/#Extrusion","page":"Ideal objects","title":"Extrusion","text":"","category":"section"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"Solids.linear_extrude\nSolids.rotate_extrude\nSolids.path_extrude","category":"page"},{"location":"ideal/#Solids.linear_extrude","page":"Ideal objects","title":"Solids.linear_extrude","text":"linear_extrude(h, s...)\nlinear_extrude(h) * s...\n\nLinear extrusion to height h.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Solids.path_extrude","page":"Ideal objects","title":"Solids.path_extrude","text":"\tpath_extrude(path, poly, options...)\n\nExtrudes the given polygon (a path of points forming a simple loop) along the given path. Both arguments are provided as a Vector{SVector{2}}.\n\nReturns a Surface (defined by points and a triangulation).\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Inserting-metadata","page":"Ideal objects","title":"Inserting metadata","text":"","category":"section"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"A couple of transformations attach metadata to objects. These are defined using the same base types as affine transforms and can therefore be applied using the same syntax, i.e. either as transform(parameters, s...) or as a product transform(parameters) * s.","category":"page"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"Solids.color\nSolids.set_parameters","category":"page"},{"location":"ideal/#Solids.color","page":"Ideal objects","title":"Solids.color","text":"color(c::Colorant, s...)\ncolor(c::AbstractString, s...)\ncolor(c::AbstractString, α::Real, s...)\ncolor(c) * s...\n\nColors objects s... in the given color.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Solids.set_parameters","page":"Ideal objects","title":"Solids.set_parameters","text":"set_parameters(;accuracy=accuracy, precision=precision)\n\nA transformation which passes down the specified parameter values to its child. Roughly similar to setting $fs and $fa in OpenSCAD.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Defining-a-custom-transformation","page":"Ideal objects","title":"Defining a custom transformation","text":"","category":"section"},{"location":"ideal/#Operations","page":"Ideal objects","title":"Operations","text":"","category":"section"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"Solids.union\nSolids.intersect\nSolids.difference\nSolids.hull\nSolids.minkowski","category":"page"},{"location":"ideal/#Base.union","page":"Ideal objects","title":"Base.union","text":"union(s, itrs...)\n∪(s, itrs...)\n\nConstruct the union of sets. Maintain order with arrays.\n\nExamples\n\njulia> union([1, 2], [3, 4])\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> union([1, 2], [2, 4])\n3-element Array{Int64,1}:\n 1\n 2\n 4\n\njulia> union([4, 2], 1:2)\n3-element Array{Int64,1}:\n 4\n 2\n 1\n\njulia> union(Set([1, 2]), 2:3)\nSet{Int64} with 3 elements:\n  2\n  3\n  1\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Base.intersect","page":"Ideal objects","title":"Base.intersect","text":"intersect(s, itrs...)\n∩(s, itrs...)\n\nConstruct the intersection of sets. Maintain order with arrays.\n\nExamples\n\njulia> intersect([1, 2, 3], [3, 4, 5])\n1-element Array{Int64,1}:\n 3\n\njulia> intersect([1, 4, 4, 5, 6], [4, 6, 6, 7, 8])\n2-element Array{Int64,1}:\n 4\n 6\n\njulia> intersect(Set([1, 2]), BitSet([2, 3]))\nSet{Int64} with 1 element:\n  2\n\n\n\n\n\nintersect(ss, others...)\n\nEach argument is a SortedSet with the same key and order type. The return variable is a new SortedSet that is the intersection of all the sets that are input. Time: O(cn log n), where n is the total number of items in all the arguments.\n\n\n\n\n\nintersect(g, h)\n\nReturn a graph with edges that are only in both graph g and graph h.\n\nImplementation Notes\n\nThis function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.\n\nExamples\n\njulia> g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> foreach(println, edges(intersect(g1, g2)))\nEdge 1 => 2\nEdge 2 => 3\nEdge 3 => 1\n\n\n\n\n\ns1 ∩ s2\n\nCompute the intersection of two line segments s1 and s2.\n\n\n\n\n\nintersect(P1::HRep, P2::HRep)\n\nTakes the intersection of P1 and P2  x  x in P_1 x in P_2 . It is very efficient between two H-representations or between two polyhedron for which the H-representation has already been computed. However, if P1 (resp. P2) is a polyhedron for which the H-representation has not been computed yet, it will trigger a representation conversion which is costly. See the Polyhedral Computation FAQ for a discussion on this operation.\n\nThe type of the result will be chosen closer to the type of P1. For instance, if P1 is a polyhedron (resp. H-representation) and P2 is a H-representation (resp. polyhedron), intersect(P1, P2) will be a polyhedron (resp. H-representation). If P1 and P2 are both polyhedra (resp. H-representation), the resulting polyhedron type (resp. H-representation type) will be computed according to the type of P1. The coefficient type however, will be promoted as required taking both the coefficient type of P1 and P2 into account.\n\n\n\n\n\nintersect(v::VRepresentation{T}, h::HRepElement)\n\nCompute the intersection of v with an halfspace or hyperplane h. The method used by default is to keep the V-representation element of v that are in h and add new ones generated as the intersection between the hyperplane defining h and the segment between two adjacent V-representation elements of v that are in either sides of the hyperplane. See Lemma 3 of [FP96] for more detail on the method.\n\n[FP96] Fukuda, K. and Prodon, A. Double description method revisited Combinatorics and computer science, Springer, 1996, 91-111\n\n\n\n\n\nintersect(s::Geometry...)\ns1 ∩ s2\n\nRepresents the intersection of given solids.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Solids.difference","page":"Ideal objects","title":"Solids.difference","text":"Solids.difference(s1, s2)\n\nRepresents the difference s1 ∖ s2.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Solids.hull","page":"Ideal objects","title":"Solids.hull","text":"hull(s::Geometry...)\n\nRepresents the convex hull of given solids.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Solids.minkowski","page":"Ideal objects","title":"Solids.minkowski","text":"minkowski(s::Geometry...)\n\nRepresents the Minkowski sum of given solids.\n\n\n\n\n\n","category":"function"},{"location":"meshing/#Meshing","page":"Meshing","title":"Meshing","text":"","category":"section"},{"location":"meshing/#Interface","page":"Meshing","title":"Interface","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Surface(objects...)","category":"page"},{"location":"meshing/#Accuracy-and-precision","page":"Meshing","title":"Accuracy and precision","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"accuracy is the maximum absolute deviation allowed when meshing an object.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The default value is 2.0, corresponding to the default value in OpenSCAD for $fs.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"precision is the maximum relative deviation allowed when meshing.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The default value is 0.02, corresponding to the default value of $fa in OpenSCAD (roughly, 1-cos(180°/$fa)).","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"To set values other than the defaults for an object, apply the set_parameters transform to that object:","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"set_parameters(accuracy=0.2)*\nCircle(2)","category":"page"},{"location":"meshing/#Circles","page":"Meshing","title":"Circles","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"A circle of radius r is replaced by an inscribed n-gon, where n is determined such that:","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"each side has a length ≈2π rn, which must not be smaller than","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":" `accuracy`\n (hence ``n \\leq 2πr/\\texttt{accuracy}``);","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"deviation from the ideal circle (sagitta) is 1cos(πn),","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"which must not be smaller than `precision`\n(hence ``n \\leq π/\\sqrt{2\\texttt{precision}}``).","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"In all cases, the number of sides is at least 4.","category":"page"},{"location":"#Solids.jl-Documentation","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"","category":"section"},{"location":"","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"warning: Warning\nThis package is very much a work-in-progress. Right now only very basic functionality is available (describing geometries, and some cases for meshing). The code is absolutely not stable, and any contributions are welcome.","category":"page"},{"location":"","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"This package provides tools for describing 3d objects in Julia. This includes both geometry functions and a syntax describing constructive geometry. This syntax is inspired by OpenSCAD, but is actual Julia code:","category":"page"},{"location":"","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"using Solids\n\nSquare(20)\n\nlinear_extrude(30) * [\n  intersection(\n    translate([10,0]) * Circle(3),\n    translate([13,0]) * Circle(3),\n  ),\n  color(\"pink\") * scale(2) * Square(1),\n]\n","category":"page"},{"location":"","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"The package is made of two parts:","category":"page"},{"location":"","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"a system for describing geometric objects;\nback-ends for converting these objects to useful formats.","category":"page"},{"location":"","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"As of 2021-01, the only useable output format is an OpenSCAD file.","category":"page"},{"location":"","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"Other planned output formats include:","category":"page"},{"location":"","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"(TODO) represented graphically using one of the Julia plotting packages;\n(TODO) converted to either a mesh or a signed distance field;\n(IN PROGRESS) directly exported as a 2d (.svg)","category":"page"},{"location":"","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"or 3d file (.stl or .ply).","category":"page"},{"location":"#Quick-start","page":"Solids.jl Documentation","title":"Quick-start","text":"","category":"section"},{"location":"#Basic-example","page":"Solids.jl Documentation","title":"Basic example","text":"","category":"section"},{"location":"","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"using Solids\nimport Solids: Square, Circle, Surface, mult_matrix, translate, scale, color\n\ns1 = union(\n  color(\"pink\")*\n  translate([3,0])*\n  scale([2,1])*\n  Circle(3),\n\n  color(\"cyan\")*\n  translate([0,5])*\n  Square([2,3])\n)\n\nSurface(s1)","category":"page"},{"location":"#I/O","page":"Solids.jl Documentation","title":"I/O","text":"","category":"section"},{"location":"","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"Solids.include\nSolids.scad","category":"page"},{"location":"#Solids.include","page":"Solids.jl Documentation","title":"Solids.include","text":"\tSolids.include(file::AbstractString, f::Function)\n\nReads given file and returns the union of all top-level Solids objects (except the results of assignments) found in the file.\n\n#### Example: contents of file `example.jl`\nC=Solids.Cube(1)\nS=Solids.Square(1)\nSolids.Circle(3)\nS\n\njulia> Solids.include(\"example.jl\")\nunion() {\n circle(radius=3.0);\n square(size=[1.0, 1.0], center=false);\n}\n\n\n\n\n\n","category":"function"},{"location":"#Solids.scad","page":"Solids.jl Documentation","title":"Solids.scad","text":"scad(filename::AbstractString, s::Geometry...)\nscad(io::IO, s::Geometry)\n\nPrints an OpenSCAD-like representation of the given solid(s).\n\nThe various scad_* functions\n\n`scad_name(s)`\n\nReturns, in printable form (e.g. Symbol or String), the OpenSCAD name of this object.\n\n`scad_parameters(s)`\n\nReturns a NamedTuple representing parameters of this object.\n\n`scad_transform(s)`\n\nPossible transformation prepended to the object.\n\n`to_scad(x)`\n\nRepresents value x (number, array, etc.) in OpenSCAD format.\n\n\n\n\n\n","category":"function"}]
}
