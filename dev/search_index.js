var documenterSearchIndex = {"docs":
[{"location":"ideal/#Ideal-Solids-objects","page":"Ideal Solids objects","title":"Ideal Solids objects","text":"","category":"section"},{"location":"ideal/","page":"Ideal Solids objects","title":"Ideal Solids objects","text":"CurrentModule = Solids","category":"page"},{"location":"ideal/","page":"Ideal Solids objects","title":"Ideal Solids objects","text":"Solids.AbstractSolid","category":"page"},{"location":"ideal/#Solids.AbstractSolid","page":"Ideal Solids objects","title":"Solids.AbstractSolid","text":"\tAbstractSolid{D,T}\n\nAbstract supertype for all solids. D is the dimension and T the type used for coordinates. A AbstractSolid{D,T} object may contain, as children, objects with other coordinate types; such coordinates will be converted to type T when rendering.\n\n\n\n\n\n","category":"type"},{"location":"ideal/#Primitive-solids","page":"Ideal Solids objects","title":"Primitive solids","text":"","category":"section"},{"location":"ideal/","page":"Ideal Solids objects","title":"Ideal Solids objects","text":"Solids.Square\nSolids.Circle\nSolids.Cube\nSolids.Cylinder\nSolids.Sphere\nSolids.Polygon\nSolids.Surface\nSolids.NeutralSolid","category":"page"},{"location":"ideal/#Solids.Square","page":"Ideal Solids objects","title":"Solids.Square","text":"Square{T}\nSquare(size, [center=false])\nSquare([size1, size2], [center=false])\n\nA square (or a rectangle) with coordinate type T, parallel to the axes. If center=true is passed, then the origin is the center-of-mass; otherwise it is the lower-left corner.\n\n\n\n\n\n","category":"type"},{"location":"ideal/#Solids.Circle","page":"Ideal Solids objects","title":"Solids.Circle","text":"Circle{T}\nCircle(r)\n\nA circle with radius r, centered at the origin.\n\n\n\n\n\n","category":"type"},{"location":"ideal/#Solids.Cube","page":"Ideal Solids objects","title":"Solids.Cube","text":"Cube{T}\nCube(size, [center=false])\nCube([size1, size2, size3], [center=false])\n\nA cube (or a rectangle parallelepiped) with coordinate type T, parallel to the axes. If center=true is passed, then the origin is the center of mass; otherwise it is the lower-front-left corner.\n\n\n\n\n\n","category":"type"},{"location":"ideal/#Solids.Cylinder","page":"Ideal Solids objects","title":"Solids.Cylinder","text":"Cylinder(h, r1, r2 [, center=false])\nCylinder(h, (r1, r2) [, center=false])\nCylinder(h, r [, center=false])\n\nWarning: Cylinder(h,r) is interpreted as Cylinder(h,r,r), not (h,r,0) as in OpenSCAD.\n\n\n\n\n\n","category":"type"},{"location":"ideal/#Solids.Sphere","page":"Ideal Solids objects","title":"Solids.Sphere","text":"Sphere{T}\nSphere(r)\n\nA sphere with radius r, centered at the origin.\n\n\n\n\n\n","category":"type"},{"location":"ideal/#Solids.Polygon","page":"Ideal Solids objects","title":"Solids.Polygon","text":"Polygon{T}\nPolygon([point1, point2, ...])\nPolygon(point1, point2, ...)\n\nA simple, closed polygon enclosed by the given vertices.\n\n\n\n\n\n","category":"type"},{"location":"ideal/#Solids.Surface","page":"Ideal Solids objects","title":"Solids.Surface","text":"Surface([points...], [faces...])\n\n\n\n\n\n","category":"type"},{"location":"ideal/#Solids.NeutralSolid","page":"Ideal Solids objects","title":"Solids.NeutralSolid","text":"NeutralSolid{D,T}\n\nA convenience type representing either an empty or full solid. This exists mostly to provide a neutral element for union() and intersect() operators, hence the name. In those cases, it is impossible to know in advance the dimension of the returned solid; hence, as an exception to the general rule, the D type parameter is either the symbol :empty or :full. Since neutral objects are removed at compile-time from corresponding CSG operations, this should have no influence on the dimension of a top-level object.\n\nThe T type parameter is always Bool.\n\n\n\n\n\n","category":"type"},{"location":"ideal/#Transformations","page":"Ideal Solids objects","title":"Transformations","text":"","category":"section"},{"location":"ideal/","page":"Ideal Solids objects","title":"Ideal Solids objects","text":"All transformations accept two possible syntaxes:","category":"page"},{"location":"ideal/","page":"Ideal Solids objects","title":"Ideal Solids objects","text":"    transform(parameters, solid1, solid2, ...)\n    transform(parameters) * solid1","category":"page"},{"location":"ideal/","page":"Ideal Solids objects","title":"Ideal Solids objects","text":"The second, multiplicative form allows easy chaining of transformations:","category":"page"},{"location":"ideal/","page":"Ideal Solids objects","title":"Ideal Solids objects","text":"    transform1(param1) * transform2(param2) * solid","category":"page"},{"location":"ideal/","page":"Ideal Solids objects","title":"Ideal Solids objects","text":"This form may also be applied to several solids by either wrapping them in a union, or equivalently, by applying it to a Vector of Solids:","category":"page"},{"location":"ideal/","page":"Ideal Solids objects","title":"Ideal Solids objects","text":"    transform(parameters) * [ solid1, solid2, ... ]","category":"page"},{"location":"ideal/#Affine-transformations","page":"Ideal Solids objects","title":"Affine transformations","text":"","category":"section"},{"location":"ideal/","page":"Ideal Solids objects","title":"Ideal Solids objects","text":"Solids.mult_matrix\nSolids.translate\nSolids.scale\nSolids.rotate\nSolids.mirror","category":"page"},{"location":"ideal/#Solids.mult_matrix","page":"Ideal Solids objects","title":"Solids.mult_matrix","text":"mult_matrix(a, [center=c], solid...)\nmult_matrix(a, b, solid...)\nmult_matrix(a, b) * solid\n\nRepresents the affine operation x -> a*x + b.\n\nExtended help\n\nnote: Types of `mult_matrix` parameters\nThe precise type of parameters a and b is not specified. Usually, a will be a matrix and b a vector, but this is left open on purpose; for instance, a can be a scalar (for a scaling) and b can be Val(false) for a linear operation. Any types so that a * Vector + b is defined will be accepted.Conversion to a matrix will be done when converting to OpenSCAD format.\n\nnote: Matrix multiplication\nChained mult_matrix operations will be combined into a single operation when possible. This saves time: multiple  (3 × n) matrix multiplications are replaced by (3 × 3) multiplications, followed by a single (3 × n).\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Solids.translate","page":"Ideal Solids objects","title":"Solids.translate","text":"translate(v, s...)\ntranslate(v) * s\n\nTranslates solids s... by vector v.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Solids.scale","page":"Ideal Solids objects","title":"Solids.scale","text":"scale(a, s...; center=0)\nscale(a; center=0) * s\n\nScales solids s by factor a. If center is given then this will be the invariant point.\n\na may also be a vector, in which case coordinates will be multiplied by the associated diagonal matrix.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Solids.rotate","page":"Ideal Solids objects","title":"Solids.rotate","text":"rotate(θ, {center=center}, {solid...})\nrotate(θ, axis=axis, {center=center}, {solid...})\n\nRotation around the Z-axis (in trigonometric direction, i.e. counter-clockwise).\n\n\n\n\n\nrotate((θ,φ,ψ), {center=center}, {solid...})\n\nRotation given by Euler angles (ZYX; same ordering as OpenSCAD).\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Solids.mirror","page":"Ideal Solids objects","title":"Solids.mirror","text":"mirror(v, s...; center=0)\nmirror(v; center=0) * s\n\nReflection with axis given by the hyperplane normal to v. If center is given, then the affine hyperplane through this point will be used.\n\n\n\n\n\n","category":"function"},{"location":"ideal/","page":"Ideal Solids objects","title":"Ideal Solids objects","text":"TODO: Solids.project, Solids.cut.","category":"page"},{"location":"ideal/#Extrusion","page":"Ideal Solids objects","title":"Extrusion","text":"","category":"section"},{"location":"ideal/","page":"Ideal Solids objects","title":"Ideal Solids objects","text":"Solids.linear_extrude\nSolids.rotate_extrude\nSolids.path_extrude","category":"page"},{"location":"ideal/#Solids.linear_extrude","page":"Ideal Solids objects","title":"Solids.linear_extrude","text":"linear_extrude(h, s...)\nlinear_extrude(h) * s...\n\nLinear extrusion to height h.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Inserting-metadata","page":"Ideal Solids objects","title":"Inserting metadata","text":"","category":"section"},{"location":"ideal/","page":"Ideal Solids objects","title":"Ideal Solids objects","text":"A couple of transformations attach metadata to objects. These are defined using the same base types as affine transforms and can therefore be applied using the same syntax, i.e. either as transform(parameters, s...) or as a product transform(parameters) * s.","category":"page"},{"location":"ideal/","page":"Ideal Solids objects","title":"Ideal Solids objects","text":"Solids.color\nSolids.set_parameters","category":"page"},{"location":"ideal/#Solids.color","page":"Ideal Solids objects","title":"Solids.color","text":"color(c::Colorant, s...)\ncolor(c::AbstractString, s...)\ncolor(c::AbstractString, α::Real, s...)\ncolor(c) * s...\n\nPaints objects s... in the given color.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Defining-a-custom-transformation","page":"Ideal Solids objects","title":"Defining a custom transformation","text":"","category":"section"},{"location":"ideal/#Operations","page":"Ideal Solids objects","title":"Operations","text":"","category":"section"},{"location":"ideal/","page":"Ideal Solids objects","title":"Ideal Solids objects","text":"Solids.union\nSolids.intersect\nSolids.difference\nSolids.hull\nSolids.minkowski","category":"page"},{"location":"ideal/#Base.union","page":"Ideal Solids objects","title":"Base.union","text":"union(s, itrs...)\n∪(s, itrs...)\n\nConstruct the union of sets. Maintain order with arrays.\n\nExamples\n\njulia> union([1, 2], [3, 4])\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> union([1, 2], [2, 4])\n3-element Array{Int64,1}:\n 1\n 2\n 4\n\njulia> union([4, 2], 1:2)\n3-element Array{Int64,1}:\n 4\n 2\n 1\n\njulia> union(Set([1, 2]), 2:3)\nSet{Int64} with 3 elements:\n  2\n  3\n  1\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Base.intersect","page":"Ideal Solids objects","title":"Base.intersect","text":"intersect(s, itrs...)\n∩(s, itrs...)\n\nConstruct the intersection of sets. Maintain order with arrays.\n\nExamples\n\njulia> intersect([1, 2, 3], [3, 4, 5])\n1-element Array{Int64,1}:\n 3\n\njulia> intersect([1, 4, 4, 5, 6], [4, 6, 6, 7, 8])\n2-element Array{Int64,1}:\n 4\n 6\n\njulia> intersect(Set([1, 2]), BitSet([2, 3]))\nSet{Int64} with 1 element:\n  2\n\n\n\n\n\nintersect(ss, others...)\n\nEach argument is a SortedSet with the same key and order type. The return variable is a new SortedSet that is the intersection of all the sets that are input. Time: O(cn log n), where n is the total number of items in all the arguments.\n\n\n\n\n\nintersect(P1::HRep, P2::HRep)\n\nTakes the intersection of P1 and P2  x  x in P_1 x in P_2 . It is very efficient between two H-representations or between two polyhedron for which the H-representation has already been computed. However, if P1 (resp. P2) is a polyhedron for which the H-representation has not been computed yet, it will trigger a representation conversion which is costly. See the Polyhedral Computation FAQ for a discussion on this operation.\n\nThe type of the result will be chosen closer to the type of P1. For instance, if P1 is a polyhedron (resp. H-representation) and P2 is a H-representation (resp. polyhedron), intersect(P1, P2) will be a polyhedron (resp. H-representation). If P1 and P2 are both polyhedra (resp. H-representation), the resulting polyhedron type (resp. H-representation type) will be computed according to the type of P1. The coefficient type however, will be promoted as required taking both the coefficient type of P1 and P2 into account.\n\n\n\n\n\nintersect(v::VRepresentation{T}, h::HRepElement)\n\nCompute the intersection of v with an halfspace or hyperplane h. The method used by default is to keep the V-representation element of v that are in h and add new ones generated as the intersection between the hyperplane defining h and the segment between two adjacent V-representation elements of v that are in either sides of the hyperplane. See Lemma 3 of [FP96] for more detail on the method.\n\n[FP96] Fukuda, K. and Prodon, A. Double description method revisited Combinatorics and computer science, Springer, 1996, 91-111\n\n\n\n\n\nintersect(s::AbstractSolid...)\ns1 ∩ s2\n\nRepresents the intersection of given solids.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Solids.difference","page":"Ideal Solids objects","title":"Solids.difference","text":"Solids.difference(s1, s2, ...)\n\nRepresents the difference s1 ∖ (s2 ∪ ..).\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Solids.hull","page":"Ideal Solids objects","title":"Solids.hull","text":"hull(s::AbstractSolid...)\n\nRepresents the convex hull of given solids.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Solids.minkowski","page":"Ideal Solids objects","title":"Solids.minkowski","text":"minkowski(s::AbstractSolid...)\n\nRepresents the Minkowski sum of given solids.\n\n\n\n\n\n","category":"function"},{"location":"start/#Quick-start","page":"Quick-start","title":"Quick-start","text":"","category":"section"},{"location":"start/#Basic-example","page":"Quick-start","title":"Basic example","text":"","category":"section"},{"location":"start/","page":"Quick-start","title":"Quick-start","text":"using Solids\nimport Solids: Square, Circle, mult_matrix, translate, scale, color\n\nunion(\n  color(\"pink\")*\n  translate([3,0])*\n  scale([2,1])*\n  Circle(3),\n\n  color(\"cyan\")*\n  translate([0,5])*\n  Square([2,3])\n)","category":"page"},{"location":"start/#I/O","page":"Quick-start","title":"I/O","text":"","category":"section"},{"location":"start/","page":"Quick-start","title":"Quick-start","text":"Solids.include\nSolids.scad","category":"page"},{"location":"start/#Solids.include","page":"Quick-start","title":"Solids.include","text":"\tSolids.include(file::AbstractString, f::Function)\n\nReads given file and returns the union of all top-level Solids objects (except the results of assignments) found in the file.\n\n#### Example: contents of file `example.jl`\nC=Solids.Cube(1)\nS=Solids.Square(1)\nSolids.Circle(3)\nS\n\njulia> Solids.include(\"example.jl\")\nunion() {\n circle(radius=3.0);\n square(size=[1.0, 1.0], center=false);\n}\n\n\n\n\n\n","category":"function"},{"location":"start/#Solids.scad","page":"Quick-start","title":"Solids.scad","text":"scad(filename::AbstractString, s::AbstractSolid...\nscad(io::IO, s::AbstractSolid)\n\nPrints an OpenSCAD-like representation of the given solid(s).\n\n\n\n\n\n","category":"function"},{"location":"#Solids.jl-Documentation","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"","category":"section"},{"location":"","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"This package presents a set of types and syntax providing tools for a simple description of constructive solid geometry objects in Julia. Syntax is inspired by OpenSCAD, but is actual Julia code:","category":"page"},{"location":"","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"using Solids\n\nSquare(20)\n\nlinear_extrude(30) * [\n  intersection(\n    translate([10,0]) * Circle(3),\n    translate([13,0]) * Circle(3),\n  ),\n  color(\"pink\") * scale(2) * Square(1),\n]\n","category":"page"},{"location":"","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"Structures defined by this package can be used in one of the following way:","category":"page"},{"location":"","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"converted to an OpenSCAD file;\n(TODO) represented graphically using one of the Julia plotting packages;\n(TODO) directly exported as a 2d (.svg) or 3d file (.stl or .ply).","category":"page"},{"location":"","page":"Solids.jl Documentation","title":"Solids.jl Documentation","text":"Solids.AbstractSolid","category":"page"}]
}
