<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ideal Solids objects · Solids.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Solids.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Solids.jl Documentation</a></li><li class="is-active"><a class="tocitem" href>Ideal <code>Solids</code> objects</a><ul class="internal"><li><a class="tocitem" href="#Primitive-solids"><span>Primitive solids</span></a></li><li><a class="tocitem" href="#Transformations"><span>Transformations</span></a></li><li><a class="tocitem" href="#Operations"><span>Operations</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Ideal <code>Solids</code> objects</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ideal <code>Solids</code> objects</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/plut/Solids.jl/blob/master/docs/src/ideal.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Ideal-Solids-objects"><a class="docs-heading-anchor" href="#Ideal-Solids-objects">Ideal <code>Solids</code> objects</a><a id="Ideal-Solids-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Ideal-Solids-objects" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Solids.AbstractSolid" href="#Solids.AbstractSolid"><code>Solids.AbstractSolid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">	AbstractSolid{D,T}</code></pre><p>Abstract supertype for all solids. <code>D</code> is the dimension and <code>T</code> the type used for coordinates. A <code>AbstractSolid{D,T}</code> object may contain, as children, objects with other coordinate types; such coordinates will be converted to type <code>T</code> when rendering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L157-L165">source</a></section></article><h2 id="Primitive-solids"><a class="docs-heading-anchor" href="#Primitive-solids">Primitive solids</a><a id="Primitive-solids-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-solids" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Solids.Square" href="#Solids.Square"><code>Solids.Square</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Square{T}
Square(size, [center=false])
Square([size1, size2], [center=false])</code></pre><p>A square (or a rectangle) with coordinate type <code>T</code>, parallel to the axes. If <code>center=true</code> is passed, then the origin is the center-of-mass; otherwise it is the lower-left corner.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L353-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Solids.Circle" href="#Solids.Circle"><code>Solids.Circle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Circle{T}
Circle(r)</code></pre><p>A circle with radius <code>r</code>, centered at the origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L380-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Solids.Cube" href="#Solids.Cube"><code>Solids.Cube</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cube{T}
Cube(size, [center=false])
Cube([size1, size2, size3], [center=false])</code></pre><p>A cube (or a rectangle parallelepiped) with coordinate type <code>T</code>, parallel to the axes. If <code>center=true</code> is passed, then the origin is the center of mass; otherwise it is the lower-front-left corner.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L363-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Solids.Cylinder" href="#Solids.Cylinder"><code>Solids.Cylinder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cylinder(h, r1, r2 [, center=false])
Cylinder(h, (r1, r2) [, center=false])
Cylinder(h, r [, center=false])</code></pre><p><strong>Warning:</strong> <code>Cylinder(h,r)</code> is interpreted as <code>Cylinder(h,r,r)</code>, not <code>(h,r,0)</code> as in OpenSCAD.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L395-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Solids.Sphere" href="#Solids.Sphere"><code>Solids.Sphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Sphere{T}
Sphere(r)</code></pre><p>A sphere with radius <code>r</code>, centered at the origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L387-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Solids.Polygon" href="#Solids.Polygon"><code>Solids.Polygon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Polygon{T}
Polygon([point1, point2, ...])
Polygon(point1, point2, ...)</code></pre><p>A simple, closed polygon enclosed by the given vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L412-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Solids.Surface" href="#Solids.Surface"><code>Solids.Surface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Surface([points...], [faces...])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L426-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Solids.NeutralSolid" href="#Solids.NeutralSolid"><code>Solids.NeutralSolid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NeutralSolid{D,T}</code></pre><p>A convenience type representing either an empty or full solid. This exists mostly to provide a neutral element for <code>union()</code> and <code>intersect()</code> operators, hence the name. In those cases, it is impossible to know in advance the dimension of the returned solid; hence, as an exception to the general rule, the <code>D</code> type parameter is either the symbol <code>:empty</code> or <code>:full</code>. Since neutral objects are removed at compile-time from corresponding CSG operations, this should have no influence on the dimension of a top-level object.</p><p>The <code>T</code> type parameter is always <code>Bool</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L445-L460">source</a></section></article><h2 id="Transformations"><a class="docs-heading-anchor" href="#Transformations">Transformations</a><a id="Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations" title="Permalink"></a></h2><p>All transformations accept two possible syntaxes:</p><pre><code class="language-julia">    transform(parameters, solid1, solid2, ...)
    transform(parameters) * solid1</code></pre><p>The second, multiplicative form allows easy chaining of transformations:</p><pre><code class="language-julia">    transform1(param1) * transform2(param2) * solid</code></pre><p>This form may also be applied to several solids by either wrapping them in a <code>union</code>, or equivalently, by applying it to a <code>Vector</code> of Solids:</p><pre><code class="language-julia">    transform(parameters) * [ solid1, solid2, ... ]</code></pre><h3 id="Affine-transformations"><a class="docs-heading-anchor" href="#Affine-transformations">Affine transformations</a><a id="Affine-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Affine-transformations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Solids.mult_matrix" href="#Solids.mult_matrix"><code>Solids.mult_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mult_matrix(a, [center=c], solid...)
mult_matrix(a, b, solid...)
mult_matrix(a, b) * solid</code></pre><p>Represents the affine operation <code>x -&gt; a*x + b</code>.</p><p><strong>Extended help</strong></p><div class="admonition is-info"><header class="admonition-header">Types of `mult_matrix` parameters</header><div class="admonition-body"><p>The precise type of parameters <code>a</code> and <code>b</code> is not specified. Usually, <code>a</code> will be a matrix and <code>b</code> a vector, but this is left open on purpose; for instance, <code>a</code> can be a scalar (for a scaling) and <code>b</code> can be <code>Val(false)</code> for a linear operation. Any types so that <code>a * Vector + b</code> is defined will be accepted.</p><p>Conversion to a matrix will be done when converting to OpenSCAD format.</p></div></div><div class="admonition is-info"><header class="admonition-header">Matrix multiplication</header><div class="admonition-body"><p>Chained <code>mult_matrix</code> operations will be combined into a single operation when possible. This saves time: multiple  (3 × n) matrix multiplications are replaced by (3 × 3) multiplications, followed by a single (3 × n).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L846-L871">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Solids.translate" href="#Solids.translate"><code>Solids.translate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">translate(v, s...)
translate(v) * s</code></pre><p>Translates solids <code>s...</code> by vector <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L887-L892">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Solids.scale" href="#Solids.scale"><code>Solids.scale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scale(a, s...; center=0)
scale(a; center=0) * s</code></pre><p>Scales solids <code>s</code> by factor <code>a</code>. If <code>center</code> is given then this will be the invariant point.</p><p><code>a</code> may also be a vector, in which case coordinates will be multiplied by the associated diagonal matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L894-L902">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Solids.rotate" href="#Solids.rotate"><code>Solids.rotate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rotate(θ, {center=center}, {solid...})
rotate(θ, axis=axis, {center=center}, {solid...})</code></pre><p>Rotation around the Z-axis (in trigonometric direction, i.e. counter-clockwise).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L922-L928">source</a></section><section><div><pre><code class="language-none">rotate((θ,φ,ψ), {center=center}, {solid...})</code></pre><p>Rotation given by Euler angles (ZYX; same ordering as OpenSCAD).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L930-L934">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Solids.mirror" href="#Solids.mirror"><code>Solids.mirror</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mirror(v, s...; center=0)
mirror(v; center=0) * s</code></pre><p>Reflection with axis given by the hyperplane normal to <code>v</code>. If <code>center</code> is given, then the affine hyperplane through this point will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L906-L913">source</a></section></article><p>TODO: <code>Solids.project</code>, <code>Solids.cut</code>.</p><h3 id="Extrusion"><a class="docs-heading-anchor" href="#Extrusion">Extrusion</a><a id="Extrusion-1"></a><a class="docs-heading-anchor-permalink" href="#Extrusion" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Solids.linear_extrude" href="#Solids.linear_extrude"><code>Solids.linear_extrude</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">linear_extrude(h, s...)
linear_extrude(h) * s...</code></pre><p>Linear extrusion to height <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L728-L733">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Solids.rotate_extrude</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Solids.path_extrude</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="Inserting-metadata"><a class="docs-heading-anchor" href="#Inserting-metadata">Inserting metadata</a><a id="Inserting-metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Inserting-metadata" title="Permalink"></a></h3><p>A couple of transformations attach metadata to objects. These are defined using the same base types as affine transforms and can therefore be applied using the same syntax, i.e. either as <code>transform(parameters, s...)</code> or as a product <code>transform(parameters) * s</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Solids.color" href="#Solids.color"><code>Solids.color</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">color(c::Colorant, s...)
color(c::AbstractString, s...)
color(c::AbstractString, α::Real, s...)
color(c) * s...</code></pre><p>Paints objects <code>s...</code> in the given color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L709-L716">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Solids.set_parameters</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="Defining-a-custom-transformation"><a class="docs-heading-anchor" href="#Defining-a-custom-transformation">Defining a custom transformation</a><a id="Defining-a-custom-transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-custom-transformation" title="Permalink"></a></h3><h2 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.union" href="#Base.union"><code>Base.union</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">union(s, itrs...)
∪(s, itrs...)</code></pre><p>Construct the union of sets. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; union([1, 2], [3, 4])
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; union([1, 2], [2, 4])
3-element Array{Int64,1}:
 1
 2
 4

julia&gt; union([4, 2], 1:2)
3-element Array{Int64,1}:
 4
 2
 1

julia&gt; union(Set([1, 2]), 2:3)
Set{Int64} with 3 elements:
  2
  3
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/abstractset.jl#L10-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.intersect" href="#Base.intersect"><code>Base.intersect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">intersect(s, itrs...)
∩(s, itrs...)</code></pre><p>Construct the intersection of sets. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; intersect([1, 2, 3], [3, 4, 5])
1-element Array{Int64,1}:
 3

julia&gt; intersect([1, 4, 4, 5, 6], [4, 6, 6, 7, 8])
2-element Array{Int64,1}:
 4
 6

julia&gt; intersect(Set([1, 2]), BitSet([2, 3]))
Set{Int64} with 1 element:
  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/abstractset.jl#L97-L119">source</a></section><section><div><pre><code class="language-none">intersect(ss, others...)</code></pre><p>Each argument is a SortedSet with the same key and order type. The return variable is a new SortedSet that is the intersection of all the sets that are input. Time: O(<em>cn</em> log <em>n</em>), where <em>n</em> is the total number of items in all the arguments.</p></div></section><section><div><pre><code class="language-none">intersect(P1::HRep, P2::HRep)</code></pre><p>Takes the intersection of <code>P1</code> and <code>P2</code> <span>$\{\, x : x \in P_1, x \in P_2 \,\}$</span>. It is very efficient between two H-representations or between two polyhedron for which the H-representation has already been computed. However, if <code>P1</code> (resp. <code>P2</code>) is a polyhedron for which the H-representation has not been computed yet, it will trigger a representation conversion which is costly. See the <a href="http://www.cs.mcgill.ca/~fukuda/soft/polyfaq/node25.html">Polyhedral Computation FAQ</a> for a discussion on this operation.</p><p>The type of the result will be chosen closer to the type of <code>P1</code>. For instance, if <code>P1</code> is a polyhedron (resp. H-representation) and <code>P2</code> is a H-representation (resp. polyhedron), <code>intersect(P1, P2)</code> will be a polyhedron (resp. H-representation). If <code>P1</code> and <code>P2</code> are both polyhedra (resp. H-representation), the resulting polyhedron type (resp. H-representation type) will be computed according to the type of <code>P1</code>. The coefficient type however, will be promoted as required taking both the coefficient type of <code>P1</code> and <code>P2</code> into account.</p></div></section><section><div><pre><code class="language-none">intersect(v::VRepresentation{T}, h::HRepElement)</code></pre><p>Compute the intersection of <code>v</code> with an halfspace or hyperplane <code>h</code>. The method used by default is to keep the V-representation element of <code>v</code> that are in <code>h</code> and add new ones generated as the intersection between the hyperplane defining <code>h</code> and the segment between two adjacent V-representation elements of <code>v</code> that are in either sides of the hyperplane. See Lemma 3 of [FP96] for more detail on the method.</p><p>[FP96] Fukuda, K. and Prodon, A. <strong>Double description method revisited</strong> <em>Combinatorics and computer science</em>, <em>Springer</em>, <strong>1996</strong>, 91-111</p></div></section><section><div><pre><code class="language-none">intersect(s::AbstractSolid...)
s1 ∩ s2</code></pre><p>Represents the intersection of given solids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L552-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Solids.difference" href="#Solids.difference"><code>Solids.difference</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Solids.difference(s1, s2, ...)</code></pre><p>Represents the difference <code>s1 ∖ (s2 ∪ ..)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L592-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Solids.hull" href="#Solids.hull"><code>Solids.hull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hull(s::AbstractSolid...)</code></pre><p>Represents the convex hull of given solids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L567-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Solids.minkowski" href="#Solids.minkowski"><code>Solids.minkowski</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minkowski(s::AbstractSolid...)</code></pre><p>Represents the Minkowski sum of given solids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/Solids.jl/blob/f0373629c2fd12174e55670b7d61df5897bba14e/src/Solids.jl#L560-L564">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Solids.jl Documentation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 13 January 2021 18:16">Wednesday 13 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
